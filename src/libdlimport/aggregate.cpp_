#include "dlimport.hpp"
#include <boost/container/flat_map.hpp>
#include <memory>
#include <any>
using dlimport::dlmodule, dlimport::aggregate;
using dlimport::param_type;
using std::string, std::optional;
using std::string_view;
using boost::container::flat_map;
static boost::container::flat_map<param_type, DCsigchar> param_map{
    {param_type::c_double, DC_SIGCHAR_DOUBLE},
    {param_type::c_bool, DC_SIGCHAR_BOOL},
    {param_type::c_pointer, DC_SIGCHAR_POINTER},
    {param_type::c_float, DC_SIGCHAR_FLOAT},
    {param_type::c_int, DC_SIGCHAR_INT},
    {param_type::c_void, DC_SIGCHAR_VOID},
    {param_type::c_long, DC_SIGCHAR_LONG},
};
class aggregate_type {
public:
    struct field {
        param_type type;
        int offset;
        int count;
    };
    aggregate_type(string tname, int max_fields, int size):
        tname_(std::move(tname)),
        max_fields_(max_fields), size_(size),
        ptr_(dcNewAggr(max_fields, size), dcFreeAggr) {
        fields_.reserve(max_fields);
    }
    void add_field(string name, field field) {
        dcAggrField(ptr_.get(), param_map[field.type], field.offset, field.count);
    }
    template <class T>
    T* to_field(void* data, const string& key) {
        return (T*)((char*)data + fields_.at(key).offset); 
    }
    template<class T>
    T& get(void* data, const string& fieldname) {
        return *(T*)((int8_t*)data + fields_.at(fieldname).offset);
    } 
    const flat_map<string, field>& fields() const {return fields_;}
    const string& tname() const {return tname_;}
    int size() const {return size_;}
private:
    flat_map<string, field> fields_;
    std::unique_ptr<DCaggr, decltype(&dcFreeAggr)> ptr_;
    int size_;
    int max_fields_;
    string tname_;
};
struct aggregate_value {
    string tname;
    std::any value;
};
static flat_map<string, aggregate_type> aggregate_registry;

static int constructor(lua_State* L) {
    aggregate_type* aggr = (aggregate_type*)lua_tolightuserdata(L, lua_upvalueindex(1));
    void* ud = lua_newuserdata(L, aggr->size());
    for (const auto& [name, field] : aggr->fields()) {
        auto getnumber = [&L, &name]() -> double {
            lua_getfield(L, 1, name.c_str());
            const double number = luaL_optnumber(L, -1, 0);
            lua_pop(L, 1);
            return number;
        };
        auto getstring = [&L, &name]() -> string_view {
            lua_getfield(L, 1, name.c_str());
            const double number = luaL_optnumber(L, -1, 0);
            lua_pop(L, 1);
            return number;
        };
        switch (field.type) {
            case param_type::c_float:
                aggr->get<float>(ud, name);
            break;
            case param_type::c_double:
                aggr->get<double>(ud, name);
            break;
            case param_type::c_pointer:
                aggr->get<void*>(ud, name);
            break;
            case param_type::c_bool:
                aggr->get<bool>(ud, name);
            break;
            case param_type::c_long:
                aggr->get<long>(ud, name);
            break;
            case param_type::c_long_long:
                aggr->get<long long>(ud, name);
            break;
            case param_type::c_int:
                aggr->get<int>(ud, name);
            break;
            case param_type::c_short:
                aggr->get<short>(ud, name);
            break;
            case param_type::c_void:
                luaL_errorL(L, "cannot have a void field");
            break;
            case param_type::lua_string:
                aggr->get<const char*>(ud, name);
            break;
        }
    }
}

int dlmodule::create_aggregate(lua_State *L) {
    dlmodule* module = dlimport::lua_tomodule(L, 1);
    string tname = luaL_checkstring(L, 2);
    aggregate_type aggr{tname, lua_objlen(L, 4), luaL_checkinteger(L, 3)};
    for (int i{1}; i <= lua_objlen(L, 4); ++i) {
        lua_rawgeti(L, 4, i);
        lua_rawgetfield(L, -1, "name");
        const string name = luaL_checkstring(L, -1);
        lua_pop(L, 1);
        lua_rawgetfield(L, -1, "type");
        const optional<param_type> type = dlimport::string_to_param_type(luaL_checkstring(L, -1));
        if (not type) luaL_errorL(L, "unknown param type '%s'", luaL_checkstring(L, -1));
        lua_pop(L, 1);
        lua_rawgetfield(L, -1, "offset");
        const int offset = luaL_checkinteger(L, -1);
        lua_pop(L, 1);
        lua_rawgetfield(L, -1, "count");
        const int count = luaL_optinteger(L, -1, 0);
        lua_pop(L, 2);
        aggr.add_field(name, {
            .type = *type,
            .offset = offset,
            .count = count
        });
    }
    aggregate_registry.emplace(std::move(tname), std::move(aggr));
    return 0;
}
